#! /usr/bin/env python

"""Implements the OS backup script.
"""

import backup_conf
import backup_operation
import program_runners
import logging
import os
import os.path
import tempfile
import subprocess
import time
import csv
try:
    import cStringIO as stringio
except ImportError:
    import StringIO as stringio

class UnmountFailed(Exception):
    pass

class BackupScript(object):
    """Top-down implementation of backup operation.
    """
    def __init__(self, options):
        """
        options: The options generated by argparse.
        """
        self.options = options
        self._setup_logging()
        self._mountpoint = None
        self._cmd = program_runners.LoggableCalls(self.log, self._noop())

    def _setup_logging(self):
        numeric_level = getattr(logging, self._log_level(), None)
        if not isinstance(numeric_level, int):
            raise ValueError('Invalid log level: %s' % self._log_level())
        logging.basicConfig(level=numeric_level)
        self.log = logging.getLogger(__name__)

    def _log_level(self):
        return self.options.log_level

    def _noop(self):
        return self.options.noop

    def run(self):
        """Run the script."""
        if self._noop():
            self.log.warn('--noop set, won\'t do anything for real')
        self._read_config()
        self._cleanup_last_time()
        try:
            self._prepare_for_backup()
            self._do_backup()
        finally:
            self._post_backup_cleanup()
            self._rsync_archives()

    def _read_config(self):
        """Read the configuration.
        """
        self.conf = backup_conf.BackupConf(self.options)

    def _cleanup_last_time(self):
        """Clean up any left-overs from last time.
        """
        self.log.info("Cleanup from last time")
        if self._snapshot_exists():
            self._post_backup_cleanup()

    def _snapshot_exists(self):
        lv_pair = [self.conf.lvm_snapshot_lv_name(), self.conf.lvm_vg()]
        found = False
        for record in self._list_current_lvs():
            if record[:2] == lv_pair:
                found = record
                break
        if found and found[4] != self.conf.lvm_lv():
            raise RuntimeError('Logical volume %r exists, but is not a snapshot of %r.' % (self.conf.lvm_snapshot_lv_name(), self.conf.lvm_lv()))
        return bool(found)

    def _list_current_lvs(self):
        lvs_cmd = ['lvs', '--separator', ',', '--noheadings']
        output = subprocess.check_output(lvs_cmd)
        lvs_fakefile = stringio.StringIO(output)
        lvs_records = list(csv.reader(lvs_fakefile))
        for record in lvs_records:
            record[0] = record[0].lstrip()
        return lvs_records

    def _prepare_for_backup(self):
        """Do any backup preparations.
        """
        self._make_lvm_snapshot()
        self._mount_lvm_snapshot()
        self._mount_binds()

    def _make_lvm_snapshot(self):
        """Make the LVM snapshot.
        """
        if not self.conf.should_snapshot_source():
            self.log.info("LVM snapshots disabled")
            return
        self.log.info("Make temporary LVM snapshot")
        lvcreate_cmd = ['lvcreate']
        lvcreate_cmd.extend(['--size', self.conf.lvm_snapshot_size()])
        lvcreate_cmd.append('--snapshot')
        lvcreate_cmd.extend(['--name', self.conf.lvm_snapshot_lv_name()])
        path = self._source_lvm_device()
        lvcreate_cmd.append(path)
        self._print_run_cmd(lvcreate_cmd)

    def _source_lvm_device(self):
        return os.path.join('/dev', self.conf.lvm_vg(), self.conf.lvm_lv())

    def _print_run_cmd(self, cmd):
        self._cmd.check_call(cmd)

    def _print_cmd(self, cmd):
        self._cmd.log_cmd(cmd)

    def _mount_lvm_snapshot(self):
        """Mount the LVM snapshot
        """
        if not self.conf.should_snapshot_source():
            return
        self.log.info("Mount temporary LVM snapshot")
        mount_cmd = ['mount']
        mount_cmd.append(self._get_snapshot_lvm_device())
        mount_cmd.append(self._temp_mount_point())
        self._print_run_cmd(mount_cmd)

    def _get_snapshot_lvm_device(self):
        return os.path.join('/dev', self.conf.lvm_vg(),
                                    self.conf.lvm_snapshot_lv_name())

    def _get_snapshot_lvm_volpath(self):
        return self.conf.lvm_vg() + '/' + self.conf.lvm_snapshot_lv_name()

    def _temp_mount_point(self):
        if self._mountpoint is None:
            if self._noop():
                self._mountpoint = os.path.join(tempfile.gettempdir(), 'a_temporary_directory')
            else:
                self._mountpoint = tempfile.mkdtemp()
        return self._mountpoint

    def _mount_binds(self):
        """Mount any bind mounts requested.
        """
        self.log.info("Mount any bind mounts")
        for bind in self.conf.bindmounts_equals():
            self._bind_mount_equal(bind)

    def _bind_mount_equal(self, bind):
        mountpoint = self._get_dir_in_mount_root(bind)
        mount_cmd = ['mount', '--bind']
        mount_cmd.append(bind)
        mount_cmd.append(mountpoint)
        self._print_run_cmd(mount_cmd)

    def _get_dir_in_mount_root(self, target_dir):
        target_dir = target_dir.lstrip('/')
        self.log.debug('_get_dir_in_mount_point:target_dir = %r', target_dir)
        return os.path.join(self._temp_mount_point(), target_dir)

    def _do_backup(self):
        """Perform the backup copying operation itself.
        """
        self.log.info("Do the backup copying operation")
        backup = backup_operation.BackupCopy(
                options=self.options,
                config=self.conf,
                backup_source_root=self._temp_mount_point()
        )
        backup.run()

    def _unmount(self, mountpoint):
        """Mount with a backoff, so it's less likely to fail completely.

        Tries up to 5 times, doubling the time it waits after each attempt.
        The first try, it waits 1 second, then it will wait
        2, 4, 8 and 16 seconds etc between attempts.

        If umount still returns an error, an error is logged and
        UnmountFailed is raised.
        """
        umount_cmd = ['umount', mountpoint]
        self._print_cmd(umount_cmd)
        if self._noop():
            return

        # This implements the backoff algorithm
        backoff = 1
        attempts = 0
        max_attempts = 5
        succeeded = False
        while attempts < max_attempts and not succeeded:
            attempts += 1
            error = subprocess.call(umount_cmd)
            if error in (1,2):
                # it wasn't mounted anyway (2) or mountpoint doesn't exist (1)
                self.log.info("nothing mounted at %r", mountpoint)
                # pretend we've succeeded - it doesn't matter.
                succeeded = True
                break
            elif error:
                self.log.warn("umount exited with status %d.  Trying again in %d seconds...", error, backoff)
                time.sleep(backoff)
                backoff *= 2
            else:
                succeeded = True
                break

        if not succeeded:
            self.log.error("%r failed %d times.  Giving up.", umount_cmd, attempts)
            raise UnmountFailed(mountpoint)


    def _post_backup_cleanup(self):
        """Remove any temporary stuff from this backup.
        """
        self._unmount_binds()
        self._unmount_lvm_snapshot()
        self._remove_lvm_snapshot()

    def _unmount_binds(self):
        """Unmount any bind mounts.
        """
        self.log.info("Unmount any bind mounts")
        for bind in self.conf.bindmounts_equals():
            self._bind_unmount_equal(bind)

    def _bind_unmount_equal(self, bind):
        mountpoint = self._get_dir_in_mount_root(bind)
        self._unmount(mountpoint)


    def _unmount_lvm_snapshot(self):
        """Unmount any LVM snapshots.
        """
        self.log.info("Unmount the temporary LVM snapshot")
        self._unmount(self._temp_mount_point())
        self._remove_temp_mount_point()

    def _remove_temp_mount_point(self):
        if self._mountpoint is not None:
            self.log.info('remove directory %r', self._mountpoint)
            if not self._noop():
                os.rmdir(self._mountpoint)
                pass
            self._mountpoint = None

    def _remove_lvm_snapshot(self):
        """Remove any LVM snapshots.
        """
        self.log.info("Remove the temporary LVM snapshot")
        lvremove_cmd = ['lvremove']
        lvremove_cmd.append('--force')  # remove active volume without confirmation
        lvremove_cmd.append(self._get_snapshot_lvm_volpath())
        self._print_run_cmd(lvremove_cmd)

    def _rsync_archives(self):
        """If configured to do so, synchronise archives to somewhere else.
        """
        if not self.conf.rsync_enabled():
            self.log.info('rsync not requested in config file')
            return
        self.log.info('rsyncing backups to another location...')
        source_dir = self._get_rsync_source_dir()
        self.log.info('rsync source: %r', source_dir)
        target_dir = self.conf.rsync_target_dir()
        self.log.info('rsync target: %r', target_dir)
        rsync_cmd = ['rsync', '-a', '-v', source_dir, target_dir]
        self._print_run_cmd(rsync_cmd)

    def _get_rsync_source_dir(self):
        path = self.conf.backup_target()
        if not path.endswith('/'):
            path += '/'
        return path
